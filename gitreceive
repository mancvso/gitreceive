#!/bin/bash

set -euo pipefail

readonly GITUSER="${GITUSER:-git}"
readonly GITHOME="/home/$GITUSER"

readonly GITREF="refs/heads/master"
readonly GITZERO="0000000000000000000000000000000000000000"

readonly GIT_RECEIVER="$GITHOME/receiver"
readonly GIT_POSTRECEIVER="$GITHOME/post-receiver"

# Given a relative path, calculate the absolute path
absolute_path() {
  local abspath
  pushd "$(dirname "$1")" > /dev/null
  abspath="$(pwd -P)"
  popd >/dev/null
  echo "$abspath/$(basename "$1")"
}

setup_git_user() {
  declare git_user="$1" home_dir="$2"
  useradd -d "$home_dir" "$git_user" || true
  mkdir -p "$home_dir/.ssh"
  touch "$home_dir/.ssh/authorized_keys"
  chown -R "$git_user" "$home_dir"
}

create_base_script() {
  declare script_path="$1"
  if [[ ! -f "$script_path" ]]; then
    cat > "$script_path" <<EOF
#!/bin/bash
#
# variables:
#
#     \$1      new revision
#     \$2      old revision
#     \$3      repository name
#     \$4      repository absolute path
#     \$5      user whom pushed commit
#     \$6      user fingerprint
#
# The script "receiver" also receive the archive of the new revision
# through stdin:
#
#     - (stdin)     archive of latest revision
#

newrev="\$1"
oldrev="\$2"
repopath="\$4"
username="\$5"
fingerprint="\$6"

# URL=https://httpbin.org/post
# echo "----> Posting to \$URL ..."
# curl \\
#   -X 'POST' \\
#   -F "newrev=\$newrev" \\
#   -F "oldrev=\$oldrev" \\
#   -F "repopath=\$repopath" \\
#   -F "username=\$username" \\
#   -F "fingerprint=\$fingerprint" \\
#   -F contents=@- \\
#   --silent \$URL

exit 0
EOF
  fi
}

setup_receiver_script() {
  declare user="$1"
  create_base_script "$GIT_RECEIVER"
  chmod +x "$GIT_RECEIVER"
  chown "$user" "$GIT_RECEIVER"
}

setup_postreceiver_script() {
  declare user="$1"
  create_base_script "$GIT_POSTRECEIVER"
  chmod +x "$GIT_POSTRECEIVER"
  chown "$user" "$GIT_POSTRECEIVER"
}

generate_fingerprint() {
  awk '{print $2}' | base64 -d | md5sum | awk '{print $1}' | sed -e 's/../:&/2g'
}

install_authorized_key() {
  declare key="$1" name="$2" home_dir="$3" git_user="$4" self="$5"
  local fingerprint="$(echo "$key" | generate_fingerprint)"
  local forced_command="GITUSER=$git_user $self run $name $fingerprint"
  local key_options="command=\"$forced_command\",no-agent-forwarding,no-pty,no-user-rc,no-X11-forwarding,no-port-forwarding"
  echo "$key_options $key" >> "$home_dir/.ssh/authorized_keys"
}

strip_root_slash() {
  local str="$(cat)"
  if [ "${str:0:1}" == "/" ]; then
    echo "$str" | cut -c 2-
  else
    echo "$str"
  fi
}

parse_repo_from_ssh_command() {
  awk '{print $2}' | perl -pe 's/(?<!\\)'\''//g' | sed 's/\\'\''/'\''/g' | strip_root_slash
}

ensure_bare_repo() {
  declare repo_abspath="$1"
  if [[ ! -d "$repo_abspath" ]]; then
    git init --bare "$repo_abspath" >/dev/null
  fi
}

ensure_prereceive_hook() {
  declare repo_abspath="$1" self="$2"
  local hook_path="$repo_abspath/hooks/pre-receive"
  cat > "$hook_path" <<EOF
#!/bin/bash
#
# NOTE: If you use -e option here. You need to pipe the "cat" command
#       in the "receive" script
set -o pipefail

cat | $self hook
exit 0
EOF
  chmod +x "$hook_path"
}

ensure_postreceive_hook() {
  declare repo_abspath="$1" self="$2"
  local hook_path="$repo_abspath/hooks/post-receive"
  cat > "$hook_path" <<EOF
#!/bin/bash
set -eo pipefail

$self post

exit 0
EOF
  chmod +x "$hook_path"
}

trigger_receiver() {
  declare repo_abspath="$2" user="$3" fingerprint="$4"
  while read oldrev newrev refname; do
    if [[ "$newrev" != "$GITZERO" && "$refname" == "$GITREF" ]]; then
      git archive "$newrev" | "$GIT_RECEIVER" "$newrev" "$oldrev" "$repo_abspath" "$user" "$fingerprint"
    fi
  done
}

trigger_post_receive() {
  declare repo_abspath="$2" user="$3" fingerprint="$4"
  while read oldrev newrev refname; do
    if [[ "$newrev" != "$GITZERO" && "$refname" == "$GITREF" ]]; then
      git symbolic-ref HEAD "$refname"
      "$GIT_POSTRECEIVER" "$newrev" "$oldrev" "$repo_abspath" "$user" "$fingerprint"
    fi
  done
}

strip_remote_prefix() {
  sed -u "s/^/"$'\e[1G'"/"
}

main() {
  readonly SELF="$(absolute_path "$0")"

  case "${1:-help}" in
  # Public commands

    init) # gitreceive init
      setup_git_user "$GITUSER" "$GITHOME"
      setup_receiver_script "$GITUSER"
      setup_postreceiver_script "$GITUSER"
      echo "Created receiver script in $GITHOME for user '$GITUSER'."
      ;;

    upload-key) # sudo gitreceive upload-key <username>
      declare name="$2"
      local key="$(cat)"
      install_authorized_key "$key" "$name" "$GITHOME" "$GITUSER" "$SELF"
      echo "$key" | generate_fingerprint
      ;;

  # Internal commands

    run)
      declare user="$2" fingerprint="$3"
      export RECEIVE_USER="$user"
      export RECEIVE_FINGERPRINT="$fingerprint"
      export RECEIVE_REPONAME="$(echo "${SSH_ORIGINAL_COMMAND:-}" | parse_repo_from_ssh_command)"
      if [[ "x$RECEIVE_REPONAME" == "x" ]]; then
        echo "Hi $RECEIVE_USER! You've successfully authenticated, but shell access is disabled."
        exit
      fi
      export RECEIVE_REPOPATH="$GITHOME/$RECEIVE_REPONAME"
      ensure_bare_repo "$RECEIVE_REPOPATH"
      ensure_prereceive_hook "$RECEIVE_REPOPATH" "$SELF"
      ensure_postreceive_hook "$RECEIVE_REPOPATH" "$SELF"
      git-shell -c "$(echo "$SSH_ORIGINAL_COMMAND" | awk '{print $1}') '$RECEIVE_REPOPATH'"
      ;;

    hook)
      trigger_receiver "$RECEIVE_REPOPATH" "$RECEIVE_USER" "$RECEIVE_FINGERPRINT" | strip_remote_prefix
      ;;

    post)
      trigger_post_receive "$RECEIVE_REPOPATH" "$RECEIVE_USER" "$RECEIVE_FINGERPRINT" 2>&1 | strip_remote_prefix
      ;;

    *)
      echo "Usage: gitreceive <command> [options]"
      ;;
  esac
}

[[ "$0" == "$BASH_SOURCE" ]] && main "$@"
